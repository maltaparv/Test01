# Python Basis  Сильная и динамическая типизация
# Class
# _myprivate
# __init__
# MY_CONSTANT

print(type(12))
print(12)
print(0b110)  # 14 десятичное
print(0o72)  # 58 десятичное
print(0xFF)  # 255 десятичное

print(5 // 2)  # 2 - деление нацело
print(5 % 2)  # 1 - остаток от деления
print(abs(-10))  # 10 - по модулю
print(round(3.5))  # 4 - округдение
print(round(3.337, 2))  # 3.34 - округдение до 2 знаков после запятой

str1 = 'Phyton \'3.6.1'
str2 = "Django \"1.11"
print(str1)
print(str2)
str3 = '''строка0
строка 1
строка 2
'''
print(str3)
s1 = "Dd-v"
s2 = 'ggg'
print(s1 + s2)
print(s1 * 5)  # повторили 5 раз
print(s1 * 2 + s2 * 4)
print(s1[0])  # первый символ  D
print(s1[-2])  # второй символ с конца  -
print(s1[-1])  # v это последний символ (первый символ с конца )
print(s1[1:3])  # срез со второго до .. не включая его   d-
print(s1[2:])  # срез  -v
print(str1[::-1])  # срез  с шагом -1  1.6.3' notyhP
print(len(str1))  # 13
print(str1.split(' '))  # разбили на 2 ['Phyton', "'3.6.1"]
s4 = "Hello, {a1} and {b1}".format(a1="Костя", b1="Шурик")
print(s4)

l1 = [1, 3, 7]
print(l1)
print(list('lists'))  # ['l', 'i', 's', 't', 's']
print(len(l1))  # 3
l4 = ['a', 'b', 'c', 'd', 'e']
print(l4[1:3])  # ['b', 'c']
l4.append('New item')
print(l4)  # ['a', 'b', 'c', 'd', 'e', 'New item']
l4.append(['x1', 'y2'])
print(l4)  # ['a', 'b', 'c', 'd', 'e', 'New item', ['x1', 'y2']]
l4.extend(['ss', 'vv'])
print(l4)  # ['a', 'b', 'c', 'd', 'e', 'New item', ['x1', 'y2'], 'ss', 'vv']
l4.pop()  # удалим последний элемент
print(l4)  # ['a', 'b', 'c', 'd', 'e', 'New item', ['x1', 'y2'], 'ss']
l4.reverse()  # переставить элементы в обратном порядке
l6 = [10, 7, 2, 5, 3]
l6.sort()  # отсортировать
print(l6)
l7 = [1, 2, ['x', 'y', 'z']]
print(l7[2][1])  # y

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
col2 = [row[1] for row in matrix]  # получить 2-ю колонку матрицы:
print(col2)  # [2, 5, 8]

sp1 = [1, 2, 3]
sp2 = sp1
sp1[0] = 6
print(sp1)  # [6, 2, 3]
print(sp2)  # [6, 2, 3] !!! - т.к. присвоили ссылку !!!

t1 = (1, 2, 3)  # кортеж - неизменяемый список
t2 = (3,)

x = set()  # множество
x.add(1)
x.add(2)
x.add(3.14)
print(x)  # {1, 2, 3.14}

words = ['hello', 'Kosta', 'Ann']
print(set(words))  # {'hello', 'Ann', 'Kosta'}

converted = set([0, 1, 1, 2, 2, 2, 2])
print(converted)  # {0, 1, 2}  - конвертировали список в множество, удалив повторяющиеся элементы.

# словари/ хэш-таблицы
Dict1 = {'key1': 'value1', 'key2': 'value2'}
print(Dict1['key2'])  # value2
Dict1['key3'] = 'vvv'
print(Dict1)  # {'key1': 'value1', 'key2': 'value2', 'key3': 'vvv'}

print('A', 'B', 'C')  # A B C
print('A', 'B', 'C', sep='--#')  # A--#B--#C
for i in range(3):
    print('i: ' + str(i))

for i in range(3):
    print('[i: ' + str(i) + ']', end='---')

seq = [1, 2, 3, 4, 5, 6]
for l in seq:
    print(l)

dict1 = {"Kost": 1, "Ann": 2, "Alex": 3}
for key in dict1:
    print(key)
    print(dict1[key])

pairs = [(1, 2), (3, 4), (5, 6)]
for item in pairs:
    print(item)

for (t1, t2) in pairs:
    print("T1: ", t1)
    print(t2)

x = [1, 2, 3, 4]
out = [(num ** 2 for num in x)]
print(out)

for i in 'Hello World':
    if i == 'o':
        continue
    print(i * 2, end='')
print(i)


def my_func(x, y, my_str='Python'):
    #   pass    # Тело функции
    """
    This is DocString
    :param x:
    :param y:
    :return:
    """
    return x + y


print(my_func(100, 3))
print(my_func("Hello, ", "Kostya"))


def func(*args):
    # a=args[0]
    # b=args[1]
    # ...
    return args


print(func(2, 7, True, "Kkdd"))  # печатает кортеж (2, 7, True, 'Kkdd')

l = [1, 2, 3, 4, 5, 6, 7, 8]


def even(num):
    return num % 2 == 0


evens = filter(even, l)
print(list(evens))

# лямбда-функция (выражение)
lambda num: num % 2 == 0
evens2 = filter(lambda num: num % 2 == 0, l)
print(list(evens2))

l1 = [1, 2, 3]
l2 = l1
print(l1, l2, id(l1), id(l2))
l1[2] = 100
print(l1, l2, id(l1), id(l2))

# in Python есть тернарный оператор
x = 2
y = x * 10 if x < 10 else x / 10

my_data = [1, 2, 3, 1, 2, 8, 1, 2, 5, 7]    # список значений
test_set = set('1235')  # ищем количество значений 1, 2, 3 и 5
result = 0  # результат - количество исследуемых значений
for item in my_data:
    result += (1 if str(item) in test_set else 0)
print('Исследуемые значения {} в списке появляются {} раз'.format(test_set, result))
"""
Функции и методы строк 
# https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html

Функция или метод	Назначение
S = 'str'; S = "str"; S = '''str'''; 
"""
S = """str"""

# ---------------------------------
"""
Литералы строк
S = "s\np\ta\nbbb"	Экранированные последовательности
S = r"C:\temp\new"	Неформатированные строки (подавляют экранирование)
S = b"byte"	Строка байтов
S1 + S2	Конкатенация (сложение строк)
S1 * 3	Повторение строки
S[i]	Обращение по индексу
S[i:j:step]	Извлечение среза
len(S)	Длина строки
S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.rfind(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.index(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.rindex(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.replace(шаблон, замена)	Замена шаблона
S.split(символ)	Разбиение строки по разделителю
S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв
S.isalnum()	Состоит ли строка из цифр или букв
S.islower()	Состоит ли строка из символов в нижнем регистре
S.isupper()	Состоит ли строка из символов в верхнем регистре
S.isspace()	Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.istitle()	Начинаются ли слова в строке с заглавной буквы
S.upper()	Преобразование строки к верхнему регистру
S.lower()	Преобразование строки к нижнему регистру
S.startswith(str)	Начинается ли строка S с шаблона str
S.endswith(str)	Заканчивается ли строка S шаблоном str
S.join(список)	Сборка строки из списка с разделителем S
ord(символ)	Символ в его код ASCII
chr(число)	Код ASCII в символ
S.capitalize()	Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.count(str, [start],[end])	Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.expandtabs([tabsize])	Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.lstrip([chars])	Удаление пробельных символов в начале строки
S.rstrip([chars])	Удаление пробельных символов в конце строки
S.strip([chars])	Удаление пробельных символов в начале и в конце строки
S.partition(шаблон)	Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.rpartition(sep)	Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.swapcase()	Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.title()	Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.zfill(width)	Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.ljust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.rjust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.format(*args, **kwargs)	Форматирование строки
"""